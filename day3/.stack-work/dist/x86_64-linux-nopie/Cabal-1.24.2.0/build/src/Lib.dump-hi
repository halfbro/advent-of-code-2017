
==================== FINAL INTERFACE ====================
2017-12-04 04:43:46.406946229 UTC

interface day3-0.1.0.0-MNdp5x0cv89yTfw26zCRH:Lib 8002
  interface hash: cac44b65cfa1d4c776a3939962c3c663
  ABI hash: 291bcaf586aa85710aa37f0be456b29f
  export-list hash: 9d5ee1f72e6cd237c0d8b98c14ed9ecb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 05c6dca22f9dd1832b6d5a0e6ea172a8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.findDistance
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity base-4.9.1.0:Data.List.NonEmpty
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Semigroup
                         base-4.9.1.0:Data.Type.Equality base-4.9.1.0:Data.Version
                         base-4.9.1.0:Data.Void base-4.9.1.0:GHC.Exts
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
b3c51397667cb424e60722aedbc4aae5
  $fFunctorZipper :: GHC.Base.Functor Lib.Zipper
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Zipper Lib.$fFunctorZipper_$cfmap Lib.$fFunctorZipper_$c<$ -}
b3c51397667cb424e60722aedbc4aae5
  $fFunctorZipper_$c<$ :: a -> Lib.Zipper b -> Lib.Zipper a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(1*U,A,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a) (w1 :: Lib.Zipper b) ->
                 case w1 of ww { Lib.Zipper ww1 ww2 ww3 ->
                 let {
                   f :: b -> a
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True) (\ (ds :: b) -> w) -}
                   = \ (ds :: b) -> w
                 } in
                 Lib.Zipper
                   @ a
                   (GHC.Base.map @ b @ a f ww1)
                   w
                   (GHC.Base.map @ b @ a f ww3) }) -}
b3c51397667cb424e60722aedbc4aae5
  $fFunctorZipper_$cfmap :: (a -> b) -> Lib.Zipper a -> Lib.Zipper b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: a -> b) (w1 :: Lib.Zipper a) ->
                 case w1 of ww { Lib.Zipper ww1 ww2 ww3 ->
                 Lib.Zipper
                   @ b
                   (GHC.Base.map @ a @ b w ww1)
                   (w ww2)
                   (GHC.Base.map @ a @ b w ww3) }) -}
c882193bf2ae596554e68ccc61973dbd
  $fShowGrid :: GHC.Show.Show a => GHC.Show.Show (Lib.Grid a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,C(U),C(C1(U)))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lib.Grid a)
                  (Lib.$fShowGrid_$cshowsPrec @ a $dShow)
                  (Lib.$fShowGrid_$cshow1 @ a $dShow)
                  (Lib.$fShowGrid_$cshowList @ a $dShow) -}
b3c51397667cb424e60722aedbc4aae5
  $fShowGrid_$cshow ::
    GHC.Show.Show a => Lib.Zipper a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),U(A,1*C1(U),C(C1(U)))><S,1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Lib.Zipper a) ->
                 case w1 of ww { Lib.Zipper ww1 ww2 ww3 ->
                 Lib.$w$cshow1 @ a w ww1 ww2 ww3 }) -}
c882193bf2ae596554e68ccc61973dbd
  $fShowGrid_$cshow1 ::
    GHC.Show.Show a => Lib.Grid a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,C(U),C(C1(U)))><S(SLL),1*U(1*U,1*U(1*U,U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Lib.Grid a) ->
                 case w1
                        `cast`
                      (Lib.N:Grid[0] <a>_R) of ww { Lib.Zipper ww1 ww2 ww3 ->
                 Lib.$w$cshow @ a w ww1 ww2 ww3 }) -}
c882193bf2ae596554e68ccc61973dbd
  $fShowGrid_$cshowList ::
    GHC.Show.Show a => [Lib.Grid a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(U),C(C1(U)))><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Lib.Grid a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lib.Grid a)
                   (\ (x :: Lib.Grid a) (s1 :: GHC.Base.String)[OneShot] ->
                    case x `cast`
                         (Lib.N:Grid[0] <a>_R) of ww { Lib.Zipper ww1 ww2 ww3 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Lib.$w$cshow @ a $dShow ww1 ww2 ww3)
                      s1 })
                   ls
                   s) -}
c882193bf2ae596554e68ccc61973dbd
  $fShowGrid_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Lib.Grid a -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,C(U),C(C1(U)))><L,A><S(SLL),1*U(1*U,1*U(1*U,U,1*U),1*U)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: Lib.Grid a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Lib.$fShowGrid_$cshow1 @ a $dShow x))
                   s) -}
b3c51397667cb424e60722aedbc4aae5
  $fShowZipper :: GHC.Show.Show a => GHC.Show.Show (Lib.Zipper a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,C(U),C(C1(U)))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lib.Zipper a)
                  (Lib.$fShowZipper_$cshowsPrec @ a $dShow)
                  (Lib.$fShowGrid_$cshow @ a $dShow)
                  (Lib.$fShowZipper_$cshowList @ a $dShow) -}
b3c51397667cb424e60722aedbc4aae5
  $fShowZipper_$cshowList ::
    GHC.Show.Show a => [Lib.Zipper a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(U),C(C1(U)))><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Lib.Zipper a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lib.Zipper a)
                   (\ (x :: Lib.Zipper a) (s1 :: GHC.Base.String)[OneShot] ->
                    case x of ww { Lib.Zipper ww1 ww2 ww3 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Lib.$w$cshow1 @ a $dShow ww1 ww2 ww3)
                      s1 })
                   ls
                   s) -}
b3c51397667cb424e60722aedbc4aae5
  $fShowZipper_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Lib.Zipper a -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),U(A,C(U),C(C1(U)))><L,A><S,1*U(1*U,U,1*U)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x :: Lib.Zipper a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Lib.$fShowGrid_$cshow @ a $dShow x))
                   s) -}
dc60bb602e704efc7d1e6bc3ce71c315
  $tc'Grid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14750095452894129699##
                   9791623416761987016##
                   Lib.$trModule
                   Lib.$tc'Grid1) -}
e85e9d4282eac9c7e28d3e8085467b5c
  $tc'Grid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Grid"#) -}
ca7650f0fd4277731ab23e7d09af99c9
  $tc'Zipper :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1431778001293239068##
                   1908251607167478949##
                   Lib.$trModule
                   Lib.$tc'Zipper1) -}
ff70db934a2f028a344267e84167450d
  $tc'Zipper1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Zipper"#) -}
502ed40c4f10e227edcc8bd61baffe2e
  $tcGrid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11906650916162255778##
                   7245373835569752893##
                   Lib.$trModule
                   Lib.$tcGrid1) -}
98d8c04b094eb6e2ba216a66db9906d6
  $tcGrid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Grid"#) -}
9155a6749504cf16f820d25db325cc6a
  $tcZipper :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10745344221613589292##
                   13406164780777118215##
                   Lib.$trModule
                   Lib.$tcZipper1) -}
5ce7d5a4299982166beec9da58495075
  $tcZipper1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Zipper"#) -}
d0853ed33fc6d22d8f0b9f3fefc13a2d
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
29f4504ec514486711005849788f70cb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
253098a42e6591eab3bc120f9489706f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "day3-0.1.0.0-MNdp5x0cv89yTfw26zCRH"#) -}
59c247de06933d60843fdbcbb921febe
  $w$cshow ::
    GHC.Show.Show a =>
    [Lib.Zipper a] -> Lib.Zipper a -> [Lib.Zipper a] -> GHC.Base.String
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,C(U),C(C1(U)))><S,1*U><L,1*U(1*U,U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: [Lib.Zipper a])
                   (ww1 :: Lib.Zipper a)
                   (ww2 :: [Lib.Zipper a]) ->
                 let {
                   z :: GHC.Base.String
                   = case ww1 of ww3 { Lib.Zipper ww4 ww5 ww6 ->
                     Lib.$w$cshow1 @ a w ww4 ww5 ww6 }
                 } in
                 let {
                   z1 :: [[GHC.Types.Char]]
                   = letrec {
                       $wgo :: [Lib.Zipper a] -> GHC.Prim.Int# -> [[GHC.Types.Char]]
                         {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                       = \ (w1 :: [Lib.Zipper a]) (ww3 :: GHC.Prim.Int#) ->
                         case w1 of wild {
                           [] -> GHC.Types.[] @ [GHC.Types.Char]
                           : y ys
                           -> case ww3 of ds1 {
                                DEFAULT
                                -> GHC.Types.:
                                     @ [GHC.Types.Char]
                                     (Lib.$fShowGrid_$cshow @ a w y)
                                     ($wgo ys (GHC.Prim.-# ds1 1#))
                                1#
                                -> GHC.Types.:
                                     @ [GHC.Types.Char]
                                     (Lib.$fShowGrid_$cshow @ a w y)
                                     (GHC.Types.[] @ [GHC.Types.Char]) } }
                     } in
                     $wgo ww2 5#
                 } in
                 let {
                   z2 :: [[GHC.Types.Char]] = GHC.Types.: @ [GHC.Types.Char] z z1
                 } in
                 letrec {
                   go :: [Lib.Zipper a] -> [[GHC.Types.Char]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Lib.Zipper a]) ->
                     case ds of wild {
                       [] -> z2
                       : y ys
                       -> GHC.Types.:
                            @ [GHC.Types.Char]
                            (Lib.$fShowGrid_$cshow @ a w y)
                            (go ys) }
                 } in
                 Data.OldList.unlines
                   (go
                      (GHC.List.reverse1
                         @ (Lib.Zipper a)
                         (GHC.List.$wunsafeTake @ (Lib.Zipper a) 5# ww)
                         (GHC.Types.[] @ (Lib.Zipper a))))) -}
a3e740e8509e072e6faa0cb309d82a14
  $w$cshow1 :: GHC.Show.Show a => [a] -> a -> [a] -> GHC.Base.String
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),U(A,1*C1(U),C(C1(U)))><L,1*U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: [a])
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Show.showList
                      @ a
                      w
                      (GHC.List.reverse1
                         @ a
                         (GHC.List.$wunsafeTake @ a 5# ww)
                         (GHC.Types.[] @ a))
                      (GHC.Types.[] @ GHC.Types.Char))
                   (GHC.CString.unpackAppendCString#
                      " "#
                      (GHC.Base.++
                         @ GHC.Types.Char
                         (GHC.Show.show @ a w ww1)
                         (GHC.CString.unpackAppendCString#
                            " "#
                            (GHC.Show.showList
                               @ a
                               w
                               (GHC.List.$wunsafeTake @ a 5# ww2)
                               (GHC.Types.[] @ GHC.Types.Char)))))) -}
18d3615112fd29059f6167861ed3abd3
  $wfindDistance :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
c882193bf2ae596554e68ccc61973dbd
  newtype Grid a = Grid (Lib.Zipper (Lib.Zipper a))
b3c51397667cb424e60722aedbc4aae5
  data Zipper a = Zipper [a] a [a]
7259631544779c51a13a4e190015c804
  findDistance :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Lib.$wfindDistance ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
instance [safe] GHC.Base.Functor [Lib.Zipper] = Lib.$fFunctorZipper
instance [safe] GHC.Show.Show [Lib.Grid] = Lib.$fShowGrid
instance [safe] GHC.Show.Show [Lib.Zipper] = Lib.$fShowZipper
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

